#!/bin/bash

log_path="/var/kushidou-touchscreen/touchscreen.log"
screenmap_path="/var/kushidou-touchscreen/config"

T0="zenity --info --title="屏幕触摸设置""
T1="--text="请选择要设置的屏幕""
T2="--ok-label="退出""
T3="--extra-button="
T4="--ok-label="返回""
T5="--text="请选择与该屏对应的触摸设备""

# 设置完立即重映射
update_xinputmapout()
{
	while read LINE
    do
        tmp1=`echo $LINE | cut -d ' ' -f 1`
        tmp2=`echo $LINE | cut -d ' ' -f 2`
		tmp3=`echo $LINE | cut -d ' ' -f 3`
		tmp4=`echo $LINE | cut -d ' ' -f 4`
		tmp5=`echo $LINE | cut -d ' ' -f 5`

		touchdev_id_change=0
		for touch_id in $(xinput | grep -i -E 'touch|ILITEK' | cut -d '=' -f 2 | cut -f 1)
		do
			input_dev=$(xinput list-props $touch_id | grep "Device Node" | awk -F : '{print $2}' | awk -F \" '{print $2}' | awk '{print $1}')
        	touch_screen=$(udevadm info $input_dev | grep "ID_INPUT_TOUCHSCREEN")
        	if [ "$touch_screen" == "" ];then
            	continue
        	fi

            dev=$(udevadm info $input_dev | grep "ID_SERIAL=" | cut -d "=" -f 2)
			vid_t=$(udevadm info $input_dev | grep "ID_VENDOR_ID=" | cut -d "=" -f 2)
			pid_t=$(udevadm info $input_dev | grep "ID_MODEL_ID=" | cut -d "=" -f 2)
			path_t=$(udevadm info $input_dev | grep "ID_PATH=" | cut -d "=" -f 2)
			if [ "$tmp1" == "$vid_t" ] && [ "$tmp2" == "$pid_t" ] && [ "$tmp3" == "$path_t" ] && [ "$tmp4" == "$dev" ];then
				touchdev_id_change=$touch_id
				xinput map-to-output $touchdev_id_change $tmp5
			fi
	    done
        
		
    done < $screenmap_path
}

# 更新设备映射信息，在原有“名称”的基础上增加vid:pid识别
# 格式：vid pid path name screen
update_screenmap()
{
	update_count=1
	res=0
	while read LINE1
    do
        tmp=`echo $LINE1 | cut -d ' ' -f 5`
        if [ $select_screen = $tmp ];then
            res=$update_count
			break
        fi
		let update_count++
    done < $screenmap_path
	# 提取名称
    touch_id_end=$(echo $select_touchdev | cut -d "(" -f 2 |  cut -d "=" -f 2 | cut -d ')' -f 1)
	select_touchdev=$(echo $select_touchdev | cut -d "(" -f 1)
	# 提取VID
	input_dev=$(xinput list-props $touch_id_end | grep "Device Node" | awk -F : '{print $2}' | awk -F \" '{print $2}' | awk '{print $1}')
	vid_touch=$(udevadm info $input_dev | grep "ID_VENDOR_ID=" | cut -d "=" -f 2)
	# 提取PID
	pid_touch=$(udevadm info $input_dev | grep "ID_MODEL_ID=" | cut -d "=" -f 2)
	# 提取ID_PATH物理路径
	path_touch=$(udevadm info $input_dev | grep "ID_PATH=" | cut -d "=" -f 2)
	# 写入配置
	sed -i "${res}c $vid_touch $pid_touch $path_touch $select_touchdev $select_screen" $screenmap_path
    echo ${res}': '$vid_touch' '$pid_touch' '$path_touch' '$select_touchdev'   -->   '$select_screen >> $log_path
	update_xinputmapout
}


select_touchdev()
{
	touchdev_count=0
	# 计算触摸屏总数
	for touch_id in $(xinput | grep -i -E 'touch|ILITEK' | cut -d '=' -f 2 | cut -f 1)
	do
		input_dev=$(xinput list-props $touch_id | grep "Device Node" | awk -F : '{print $2}' | awk -F \" '{print $2}' | awk '{print $1}')
		touch_screen=$(udevadm info $input_dev | grep "ID_INPUT_TOUCHSCREEN")
		if [ "$touch_screen" == "" ];then
			continue
		fi
			let touchdev_count++
	done

	count_tmp=0
	# 逐项列出屏幕的名字
	for touch_id in $(xinput | grep -i -E 'touch|ILITEK' | cut -d '=' -f 2 | cut -f 1)
    do
		input_dev=$(xinput list-props $touch_id | grep "Device Node" | awk -F : '{print $2}' | awk -F \" '{print $2}' | awk '{print $1}')
		touch_screen=$(udevadm info $input_dev | grep "ID_INPUT_TOUCHSCREEN")
		if [ "$touch_screen" == "" ];then
			continue
		fi
			dev=$(udevadm info $input_dev | grep "ID_SERIAL=" | cut -d "=" -f 2)"(id="$touch_id")"
			let count_tmp++

			if [ $count_tmp = 1 ];then
				dev_bt1=$dev
			elif [ $count_tmp = 2 ];then
				dev_bt2=$dev
			elif [ $count_tmp = 3 ];then
				dev_bt3=$dev
			elif [ $count_tmp = 4 ];then
				dev_bt4=$dev
			else
				echo "连接的触摸设备的数量超出程序范围(max=4)" >> $log_path
				echo "连接的触摸设备的数量超出程序范围(max=4)"
			fi
  	done

	case $touchdev_count in
	0) echo "没有触摸设备连接" >> $log_path && echo "没有触摸设备"
   	;;  
   	1) select_touchdev=`$T0 $T5 $T3$dev_bt1 $T4`
   	;;  
  	2) select_touchdev=`$T0 $T5 $T3$dev_bt1 $T3$dev_bt2 $T4`
    ;;  
   	3) select_touchdev=`$T0 $T5 $T3$dev_bt1 $T3$dev_bt2 $T3$dev_bt3 $T4`
   	;;
	4) select_touchdev=`$T0 $T5 $T3$dev_bt1 $T3$dev_bt2 $T3$dev_bt3 $T3$dev_bt4 $T4`
	;;
   	*) echo "连接触摸设备的数量超出范围（max=4）" >> $log_path
    ;;
    esac
    echo selected:$select_touchdev

    if [ "$select_touchdev" = "" ];then
       	#break
		echo "return"
   	else
       	update_screenmap
   	fi
}

init_screenmap()
{
	# 初始化时添加新的屏幕
	touch $log_path
    touch $screenmap_path
	
	for screen_connect in $(xrandr | grep " connected" | cut -d ' ' -f 1)
	do
		sign=0
		while read LINE
        do
            screen_tmp=`echo $LINE | cut -d ' ' -f 5`
            if [ "$screen_tmp" == "$screen_connect" ];then
                sign=1
                break
            fi 
        done < $screenmap_path

        if [ $sign = 0 ];then
            echo "0 0 0 0 $screen_connect" >> $screenmap_path
        fi
	done
}


echo -e $(date)"\t开始配置触摸屏" >> $log_path
while [ 1 ]
do
	init_screenmap
	# 计算屏幕总数==配置文件行数
	screen_count=$(cat $screenmap_path | wc -l)
	button_count=1
	# 对各屏幕分别进行配对，最多4屏
	while read LINE
	do
		L_LINE=`echo $LINE | cut -d ' ' -f 5`
		case $button_count in
		1) bt1=$L_LINE
		;;
		2) bt2=$L_LINE
		;;
		3) bt3=$L_LINE
		;;
		4) bt4=$L_LINE
		;;
		*) echo "连接屏幕的数量超出程序范围(max=4)" >> $log_path
			exit 1
		;;
		esac
		let button_count++ 
	done < $screenmap_path
	
	# 针对某个屏开始配置
	case $screen_count in
	0) echo "没有屏幕连接" >> $log_path
	;;
	1) select_screen=`$T0 $T1 $T2 $T3$bt1 $T2`
	;;
	2) select_screen=`$T0 $T1 $T2 $T3$bt1 $T3$bt2 $T2`
	;;
	3) select_screen=`$T0 $T1 $T2 $T3$bt1 $T3$bt2 $T3$bt3 $T2`
	;;
	4) select_screen=`$T0 $T1 $T2 $T3$bt1 $T3$bt2 $T3$bt3 $T3$bt4 $T2`
	;;
	*) echo "连接屏幕的数量超出程序范围(最大连接数量4)" >> $log_path
	   exit 1
	;; 
	esac
    echo selected:$select_screen
	# 有屏则开始选择触摸，最后一行就接触配置
	if [ "$select_screen" = "" ];then
		echo -e $(date)"\t配置完成" >> $log_path
		echo "===========================================" >> $log_path
		echo " " >> $log_path
		break
	else
		select_touchdev
	fi
done

